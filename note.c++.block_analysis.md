---
id: omhnlovfxrqevkp9ng7mldl
title: Block_analysis
desc: ''
updated: 1702055023111
created: 1702039797160
---

#### scene
**常见的同步结构组成**
1. 单纯地使用 mutex

        注意不同mutex的互相依赖关系，避免造成死锁
2. mutex + condition + 原子标志位作为condition 条件, 多组mutex + condition 互相依赖
    
        1.一个是单个mutex重复嵌套阻塞: 
        2.wait 阻塞 !!!! 要清楚意识到，wait方是不会主动检查条件的, 只有第一次进入wait才会主动检测一次，所以wait的情况分两种
            1.wait 真的条件未满足
            2.wait 条件已经满足但是没有人进行通知！！还要注意通知一般是双向的，永动机
            所以总结: wait wait，wait的一个是有人通知，这才是首要，第二个才是条件成立，退出wait
        3.多人并行发出唤醒时，wait 方正在唤醒中时，导致唤醒丢失
        4.编程范式: 
            0.所有的同步对象，以及标志位的相关操作都应该封装为可读的接口，在编写的过程中需要不断调试后填充接口逻辑，这样最高效清晰, 可读性第一！可读性第一！=> 可改性 可扩展性 伸缩性
            总结: 让接口组织去维护逻辑的可读，让接口实现去封装所有标志细节
            1.切勿急着使用mutex，编写的顺序应该是从内向外（即先编写private ），从无锁到有锁
            之所以分private inner的接口，是因为会存在内部的接口复用，通常inner不随意加锁，会赵成锁嵌套，通常封装完毕后，从pulibc接口 外部线程环境的角度，进行二次封装加锁
            2.从内向外，从condition wait到额外标志位，优先处理condition部分
3. mutex + condition + condition标志位 + while 轮询 + 轮询控制标志位 + 后台轮询线程 进行定期脏标志检查

        1.内存越界，悬空指针访问导致的标志位异常值，逻辑阻塞 : 标志位合法性检查
        2.重在梳理每一个独立线程逻辑，以及整体逻辑, 然后先循环条件，再condition条件