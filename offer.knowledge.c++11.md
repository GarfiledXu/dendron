---
id: gv85oikwt649kkpameaqvto
title: C++11
desc: ''
updated: 1732531936459
created: 1730692221922
---

### c++ 11 新特性

### c++ 关键字

### 列表初始化

### 右值引用 移动语义 完美转发

### 智能指针

### lambda表达式
- 表达式和函数?

### 内存对齐

### 原子操作

### c++ 对象模型

### c++ 内存模型

### 编程范式和遵守规则

### 剑指offer 摘抄
1. 4个 类型转换相关的关键字 [p23]
2. sizeof [p23]
   1. 定义一个空class，占用空间多少?
   2. 添加一个构造函数和析构函数呢?
3. 分析代码段的编译或者运行结果? [p24]
    1. 传值构造函数会导致递归调用 不允许使用, 最终会编译错误
    2. 实现一个已有类的部分成员函数 各种构造函数，以及修饰符使用

### ISO 标准
什么是ANSI? American National Standards Insitute
什么是ISO标准? International Organization for Standardization
ISO/IEC? International Organization for Standardization / International electrotechnical commisson

### 特性选择之二义性
- 成员函数以及构造函数的重载和设置默认参数以及重载的替代方案: 功能描述命名
  - 看似合理，但实则存在不一致(二义性)风险，会制造迷惑，需要承担技术债务的行为: 构造函数使用函数重载+默认参数+默认构造 -> (合理)确保唯一的默认构造，初始化所有成员 + 函数重载 + 不使用默认参数 
  - 准则: 普通函数 非必要不使用函数重载，优先使用默认参数，并且不与函数重载混用，普通函数的函数重载替换: 通过以更精准的函数命名来表示函数间的异同点，以及语义，而不是随意的重载，来加重使用负担
  - 准则: 构造函数 不要使用默认参数，优先使用函数重载，尽量保证成员的唯一默认构造

### 思考 set and get 函数
平凡且强行的set 和 get并不能带来变量操作以外额外的语义，更不如将变量的操作直接包含在直接需要的并且拥有具体命名语义的函数中; 即具体的需求函数来抹除多余的set和get函数;


### 智能指针 和 所有权 以及对象传递
智能指针分类型，本质上不同的智能指针类型表示了 不同的 对象所有权处理规则，普遍反应在函数之间的对象传递行为上，而拥有了对象的所有权则表明了该处担负了对象的生成与销毁的处理责任
在选择 对象的传递方式时，首要应该明确 传递后对对象的调用情况(需求); 若是继续传递到其他函数，那就意味着所有权共享，当前的调用层将难以明确对象的销毁时机；若是仅仅进行调用，那么通过智能指针的规则传递对象，意义并不大;
使用了 std::share_ptr 则表明了将共享所有权，下一层的未知调用将参与对象所有权的控制; 并且需要明确 传递时带来的性能开销(而非内存开销)，共享所有权本质上就是两个对象的相关数据的拷贝，那就意味着会关联线程安全问题，要保证线程安全，那就必然会牵扯到互斥带来的性能成本;
使用了 std::unique_ptr 则表示了将所有权进行转移，当前层交出所有权;
直接使用原始指针进行传递，那就意味着 直接传递了所有权，也就意味着接受的一层需要进行额外的指针检查等，包括整个对象的管理就依赖于 定义专用的创建和清理函数，至于是否直接使用原始指针，取决于具体的应用场景和调用时对应的所有权风险; 如果 定义的配套规则不够规范，那就意味着调用方推理指针使用的风险越大;
直接通过引用类型进行引用传递行为，那就意味着，传递后的层次不需要像原始指针一样进行指针检查，这一行为交由上层进行判断并且解引用;
总结: 
  
    智能指针 普通指针 以及引用传递等 不同的方式都对应着不同的 对象的所有权 处理规则
    从机制的复杂性上进行排序: 引用类型 < 普通指针 < uniq_ptr < share_ptr
    使用哪种方式，取决于在对象的调用场景下，对对象的生命周期和所有权的推理难度; 只有在困难的情况下，才使用share_ptr，滥用必然会造成技术债务引发埋藏更多的bug;
