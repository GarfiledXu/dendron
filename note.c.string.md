---
id: 89qsb851up90yz1jcrddvnh
title: String
desc: ''
updated: 1737167179407
created: 1737077118612
---

### `\0` 和 `\n` 和 EOF 以及系统调用的关系
- EOF 是什么? 与其他两个的区别，`\n\f` 是两个字符还是一个字符?
- 哪些行为会自动添加上面的字符?
- 哪些系统调用 会判断上面的字符作为条件，去阻塞或者退出?
- 自定义的字符串变量，常量，数组，以及命令行参数等是否会自动添加 `\0`?
- 编译器的`\0`相关的自动行为?


### 编译器自动添加 `\0`
当有字符常量初始化行为时，编译器会自动在末尾添加`\0`
以及字符串相关的函数处理时会自动添加或者忽略，比如strlen只统计除`\0`以外的，strcpy拷贝时会自动添加`\0`, strcat
即 与c中与str相关的处理和调用，都会进行`\0`的处理, 而一般像 memcpy，read，write这样的系统调用则不会
```c
char str1[] = "hello";
char str2[10] = "world";

//so
char str3[5] = "hello"; //编译器报错

//copy
char dest[10];

strcpy(dest, "hello"); 
```

### 基于 `\0` 的行为
总结: 先判断函数是否属于字符处理函数族，遍历字符串时作为终止符，并且进行字符计数时不纳入统计; 生成字符串时作为补充字符
1. `strlen` 自动判断和忽略`\0`字符
2. `strcpy` and `strncpy` 判断到 `\0`自动结束
3. `strcat` and `strncat` 判断到将目标str的`\0`作为拼接七点
4. `strcmp` and `strncmp` 会以`\0`作为遍历结束条件
字符串流处理的库函数
5. `printf` 读取标准输出流，一般会以字符串中的`\0`作为填充结束条件, 即在字符串的格式化处理中 `\0` 被视为`操作终止符`
6. `scanf` 读取标准输入流，通过格式化占位符的方式去读取，与printf类似，不同点在于最后会添加`\0`
7. `fprintf` 与printf类似, 只是printf是字符串与标准输出流，而f_函数族是字符串与文件流
8. `fputs` 与fprintf相比，没有格式化
9. `fgets` 不会对字符串中的`\0`进行判断，但会在读取到`\n`停止读取，并且在`\n`之后添加`\0`,所以如果读取到的字符串包含了`\0`,那么拿到后在其他字符串处理的函数中可能结果会发生异常, 即 `fgets`的操作终止符只有`\n`并且是最后会自动添加`\0`到末尾的
fgets的目的是返回读取的字符串指针，所以当返回 NULL 时作为结束条件
10. `getc` 也是和文件流缓冲区对接，不会处理\0和\n, 读取到EOF时返回EOF -1
getc的目的是返回int型的字符，所以将 EOF 作为结束条件
11. `putc` 和文件流缓冲区对接，不会处理\0和\n, 如果写入失败则返回EOF -1
putc同理

EOF 什么时候会存在?和EOF 相关的调用
1. EOF 是一个结束标志，用来作为流结束的返回通知, 这个流通常是 文件流FILE完全被读取后返回， 标准输入流stdin，当用户触发结束信号(ctrl D + ctrl z)时返回, 管道流 popen 写入端关闭后返回，套接字流转化为FILE流以后。如果是意外关闭和其他错误，那么返回的可以是错误值而不是EOF
2. getc,fgetc 返回字符，或者EOF， fscanf 从文件流，通过格式化占位符的方式读取赋值给变量，到达流结尾时或者发生了错误 返回EOF，然后具体原因通过ferror检查

### 文件流缓冲刷新模式
1. 全缓冲: 等内部缓冲全部都填满
2. 行缓冲: 数据中存在换行符`\n`
3. 无缓冲: 通过接口写入即刷新



二进制流处理的库函数
1.  `fread` 不处理字符串判断
2.  `fwrite` 不处理字符串判断
3.  `popen` 管道处理

### 字符串与 `sizeof` 和 `strlen`
1. 对于字符串数组，sizeof 返回数组的总长度，包括 \0
2. 对于字符串指针，sizeof 无法判断其指向内容的长度，只是返回指针变量本身的数据大小，通常是8字节
3. **那么strlen返回的是内存长度吗？no no, strlen返回的是除\0字符以外的字符长度**


### 通常c语言字符串的封装
```c
struct c_str{
    char* p;
    size_t len;
};
再以此为基本类型，封装字符串操作相关的函数;
```