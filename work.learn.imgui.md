---
id: lk7kqxqmdtxu90zu1d6j38y
title: Imgui
desc: ''
updated: 1711012053689
created: 1702989263030
---

#### imgui
1. 源码的文件组织结构
2. example 工程的组织结构的疑惑?
3. backend接口是如何划分的
4. frontend接口是如何调用backend，除了基础的widget实现和layout，重点关注:如何嵌入自定义渲染窗口的
5. 抽象概念

#### 关于即时模式 immediately mode
与其说是实时模式，不如称之为帧模式，以帧为单位 进行一次绘制，同样也以帧为单位进行事件响应，也就是说在当前帧内发送了事件，那么事件响应最快也是下一帧画面

#### refe
[offical: focus](https://www.dearimgui.com/)
[github: imageui](https://github.com/ocornut/imgui)
[blog: ImGui介绍与使用](https://www.thisisgame.com.cn/tutorial?book=cpp-game-engine-book&lang=zh&md=24.%20engine_editor/24.3%20imgui.md)
[blog: 浅谈ImGui实现](https://zhuanlan.zhihu.com/p/380365637)
[blog: IMGUI通读01](https://sixgodzhang.github.io/2021/04/22/%E7%B3%BB%E5%88%97023%20%E6%A1%86%E6%9E%B6%E7%B1%BB/IMGUI/IMGUI%E9%80%9A%E8%AF%BB01%EF%BC%9A%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/)
[github: tryOpengl](https://github.com/HaiBooLang/TryOpenGL)

#### extend
[github: extend show](https://github.com/ocornut/imgui/issues/123)


#### 扩展自定义 ui 控件
##### 基本思路
- 任何组件元素的行为以及自适应操作都是首先基于所在父组件(如window，child window)状态进行的
- 其次是来源自 事件响应
- imgui 本质上是 基于全局数据结构驱动的，按帧渲染频率进行更新的ui框架
  1. 由于是全局数据，所以所有的组件区分，是基于组件id的存储 + 全局函数进行的
  2. ui的响应流程: 屏幕事件的生成 => 事件+坐标数据 => 在渲染loop中的一帧 进行数据 push 到全局数据结构 => 所有控件根据更新的全局数据 进行变化响应
  3. ui的组件 layout 依旧依赖于全局的数据结构 + id 进行一次性布局，而不是依赖对象
  4. imgui 是如何进行 事件传递的，当ui组件重叠时，如何让上层正确的组件获取到事件，而下层的屏蔽调组件
- 所以，首要做的是，整理己方的需求，要做到哪些自适应，基于从父组件获取到的哪些属性
  1. 窗口此时所在坐标 相对于整个screen
  2. 组件自身所在坐标 相对于整个screen
  3. 组件相对于窗口的位置信息
  4. 窗口的事件，即折叠，完全被覆盖等
- 自己的组件图形如何绘制
  1. imgui 提供了哪些绘制接口？
  2. 如何判断此时的元素是否进行绘制的？
  3. 基本的画布标记如何实现？
- 如何将opengl的纹理绘制与组件结合？
  1. imgui 自定义组件 计算出 gl 最终绘制的矩形范围，以及是否绘制的信号
  2. gl 渲染封装提供基本的图形变换，以及操作， 最终由组件进行 数据传递 和 执行触发
  3. imgui 拥有封装好的opengl渲染器，监听 事件变化，转化为渲染器的调用操作，实现画面响应
  4. 直方图计算等各种额外的功能
  5. 一个 view 提供多个通道接入，实现多通道显示或者是单个通道切换显示，以及通道融合
     1. 通道支持 图片 以及 视频流 或者 文件路径 url远程路径 smb远程路径
     2. 通常流程是 一个swtich 断开通道解析，然后各种组件配置，最后是switch 打开通道解析，正式执行
     3. 适应模式: 
        1. 等比例自适应: 根据当前的父窗口，缩放到图像能够完整等比例并最大程度在父窗口中
        2. 非等比例适应: 与上衣模式的区别在于，宽高变化，根据父窗口进行变化
        3. 固定大小模式，提供宽高设置输入 + 等比例拖动调节按钮
        4. 当多通道显示时，提供通道显示排列，以及布局设置
           1. 先设置布局，如提供固定的布局模式，1行几个，2行几个，布局完成后每一个位置存在编号
           2. 提供通道编号来指定对应排列

    4. 帧率控制: 跳帧 帧缓存 选帧
    4. 切换渲染器，以及渲染模式，是使用yuv转码rgb的统一方式，还是对应版本的渲染器
    5. dump和标记功能
       1. dump 原图 
       2. dump 编码视频
          1. 使用原图编码
          2. 使用渲染数据编码
       3. 标记
          1. 画笔
          2. 矩形框
          3. 选型框
          4. 退格
          5. 清空
       4. dump 图片+标记混合图
       5. dump 图片+标记混合编码视频
    6. 响应窗口折叠，关闭部分功能
    7. 对外暴露: 通道图像变化操作
    8. 配置保存
    9. 事件: 记录悬停位置
    10. 放大镜功能

- opengl 的封装 <渲染器>
    1. 指哪打哪，在数据来源确定以后，根据坐标以及范围对目标区域进行渲染
    2. 变化， 在基础的画面渲染基础上，提供各种图像变化处理: 缩放 + 镜像 + 颜色空间 + 灰度 + 马赛克化 + 锐化 + 旋转 + 混合 + 变形 镜像 翻转 调色
    3. 基础图元绘制 -- 这一部分与 imgui 可互相替换
   
- ImageRender
  1. draw_enable()
  2. draw_primitive_relative_to_root_window()
  3. draw_primitive_relative_to_pic()


##### plan
- [ ] 多格式yuv绘制
   - [ ] rgb
   - [ ] uyvy
   - [ ] nv21
   - [ ] nv12
   - [ ] i420
   - [ ] rgba
   - [ ] bgr
   - [ ] bgra
   - [ ] yuyv
- [ ] 加载大量纹理，以及多纹理数据处理
- [ ] 图像变换实现
  - [ ] rgb2yuv, yuv2rgb互转实验查看精度损失
  - [ ] 起点坐标
  - [ ] 宽高
  - [ ] 像素平铺方式切换
  - [ ] 镜像
  - [ ] 旋转
  - [ ] 缩放
  - [ ] 灰度化
  - [ ] 马赛克化
  - [ ] 透明度
  - [ ] 多张融合