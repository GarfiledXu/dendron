---
id: w1ixgddwy1fnsx5qh520po0
title: Tcp
desc: ''
updated: 1736840708837
created: 1709793993963
---

### refe
[TCP 和 UDP 可以使用同一个端口吗？](https://xiaolincoding.com/network/3_tcp/port.html#tcp-%E5%92%8C-udp-%E5%8F%AF%E4%BB%A5%E5%90%8C%E6%97%B6%E7%BB%91%E5%AE%9A%E7%9B%B8%E5%90%8C%E7%9A%84%E7%AB%AF%E5%8F%A3%E5%90%97)
[小林: 计算机图解系列](https://xiaolincoding.com/)
[知乎:程序员的进阶之路 TCP篇](https://www.zhihu.com/tardis/bd/art/3383813786?source_id=1001)


### 网络分析工具

### 网络模型的7层 4层 5层

### message header data size
TCP: 固定头部 20 字节,最大扩展到60字节
1. 源端口: 2字节，目标端口: 2字节
2. 校验和 checksum: 2字节
3. 窗口大小 window size: 2字节
4. 紧急指针 urgent pointer: 2字节
5. 序列号 sequence number: 4字节
6. 确认号 acknowledgment: 4字节
7. 数据偏移 data offset: 4位 + 标志位 flags: 6位 + 保留 reserved: 6位 = 2字节
8. 可变扩展字段: 最大60字节

UDP: 固定头部8字节, 最大是TCP的 `2/5` `8:20`
1. 源端口: 2字节，目标端口: 2字节
2. 长度: 2字节
3. 校验和 checksum: 2字节

**可以看出，udp的固定头部连tcp一半的大小都没有，相同部分为4字节的源端口和目的端口，以及2字节的校验和，差异点仅仅是udp多了2字节的长度数据，2字节的长度字段，说明udp的数据包最大是2的16次方-1=65535字节，而在ip层受限于MTU（最大传输单元），假设MTU 1500字节，那么将会进行分片处理，分片后的数据结构: 1500=20+8+自定义数据 其中20字节是ipv4头部字段，8字节是udp头部字段**

### connect and close
**建立连接依靠三次握手 three-handshake**
1. --> SYN
2. SYN-ACK <--
3. --> ACK

**关闭连接通过四次挥手 four-teardown**
1. --> FIN
2. ACK <--
3. FIN <--
4. --> ACK


### fast concept
**C/S not equivalent to sender and receiver**
client 和 server 决定了建立链接的顺序和方式，但和数据的发送方以及接收方没有关联，tcp是点对点 全双工的，一个链接由一个fd进行标识，client端既可以是数据的sender，也可以是数据的receiver，所以在讨论tcp的机制原理时，通常我们要对讨论场景进行一步步的条件加设，先分`客户端和服务端`,然后再分`发送方和接收方`

### base mechanism
1. 最基本的，发送方如何确认自己的消息是否被对方接收成功?
约定ACK消息，发送以后等待ACK，`接收ACK`可以确认成功发送

2. 发送方没有收到ACK，即`ACK超时`,那么有可能是 `消息丢失`或者`ACK丢失`, 如何处理ACK超时？
消息重发，重新等待ACK, 即`ACK超时重发`

3. TCP如何进行流量控制?
这里的控制本质上是 接收方对发送方的数据流量控制，即`消费者-生产者`的`供-需`调整
基本算法: `滑动窗口` 发送方发送的数据包会附带发送的 数据序号和长度，接收方发送的ACK会附带接收的 数据序号，在接收方返送的ACK中再附带 windows长度,来表明和限制发送方下次发送的数据大小

4. TCP的如何进行拥塞控制？和流量控制有什么区别?
流量控制的需求 来源于 发送方和接收方中，接收方的一个 供需调整
拥塞控制的目的 是在资源竞争的网络环境下 调节自身的发送速率来防止网络拥塞恶化
基本算法: `low-start 满启动+速率检测` 其中在逐渐增大发送速率的过程中 通过ACK内容来判断 `丢包和延迟情况` 确定一个理想速率

5. 传输数据时发生了错误，长度不变但bit反转了怎么办?
通过tcp和udp头部中的checksum，发送方对数据取和取反，接收方进行计算对比，针对单比特翻转有效
??? 为什么要用反码求和的方式计算校验和

### tcp与其他传输协议的对比，优缺点，比如 head-line blocking problem
head-line 可以理解为靠前需要 传输的分片
blocking 理解为被阻塞
解释: tcp在进行分片报文传输的过程中 是在一个窗口内进行流水线传输的，并不是等当前的报文传输成功并且收到ack后才传输下一个，而是1， 2， 3，4连续传输
但是一旦靠前的分片由于丢包等原因传输失败了，相当于该数据blocking，那么意味着要等待触发超时机制，然后进行重传，并且先前发送的后序分片也会被丢弃
总结: 在丢包场景下，并且是一个大范围的滑动窗口，非现代的tcp，会由于窗口中某个序号数据无法到达而阻塞等待重传并且丢弃后序数据，比较影响效率，在现代tcp中，加入了选择重传，不丢弃后序已传的数据包，会改善这个问题，但tcp是单点 有序的传输，只要窗口中的中间段数据丢包，那么整个窗口中的数据都会在缓冲区中等待知道数据被重传，这个问题就会存在。
sctp是如何针对这类问题处理的???
