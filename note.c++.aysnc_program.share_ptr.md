---
id: 897ey4qx4lf05a3lj6qmbib
title: Share_ptr
desc: ''
updated: 1757937703161
created: 1757582022777
---

## rpc_core 中使用c++现代特性解决异步编程时生命周期和资源管理,竞态问题

1. 为什么会有这些问题？
   1. 异步编程，lambda回调，链式调用
   2. 多线程环境


## debug

高并发情况下的崩溃

```bash
root@Rockchip:/oem$ gdb
gdb            gdb-add-index  gdbserver
root@Rockchip:/oem$ gdb ./test_rpc_s /mnt/sdcard/
core-1295-ydn-rk         core-2534-test_rpc_c     core-354-daemon_service
core-1301-test_rpc_s     core-2746-test_rpc_c     core-374-ydn-rk
core-1346-test_rpc_c     core-2815-test_rpc_s     core-377-ydn-rk
core-1501-test_rpc_s     core-3313-test_rpc_s     core-3886-mock_rpc_c
core-1984-test_rpc_s     core-3335-test_rpc_s     core-823-test_rpc_s
core-2451-test_rpc_s     core-3392-test_rpc_s     core-861-test_rpc_s
core-2510-test_rpc_c     core-3511-test_rpc_s     swapfile
root@Rockchip:/oem$ gdb ./test_rpc_s /mnt/sdcard/core-3511-test_rpc_s
GNU gdb (GDB) 10.2
Copyright (C) 2021 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.
Type "show copying" and "show warranty" for details.
This GDB was configured as "arm-rockchip830-linux-uclibcgnueabihf".
Type "show configuration" for configuration details.
For bug reporting instructions, please see:
<https://www.gnu.org/software/gdb/bugs/>.
Find the GDB manual and other documentation resources online at:
    <http://www.gnu.org/software/gdb/documentation/>.

For help, type "help".
Type "apropos word" to search for commands related to "word"...
Reading symbols from ./test_rpc_s...
(No debugging symbols found in ./test_rpc_s)
[New LWP 3511]
[New LWP 3514]
Core was generated by `./test_rpc_s'.
Program terminated with signal SIGSEGV, Segmentation fault.
#0  0xa6e93f8c in std::_Rb_tree_rebalance_for_erase(std::_Rb_tree_node_base*, std::_Rb_tree_node_base&) () from /lib/libstdc++.so.6
--Type <RET> for more, q to quit, c to continue without paging--bt
[Current thread is 1 (LWP 3511)]
(gdb) b
Breakpoint 1 at 0xa6e93f8c
(gdb) bt
#0  0xa6e93f8c in std::_Rb_tree_rebalance_for_erase(std::_Rb_tree_node_base*, std::_Rb_tree_node_base&) () from /lib/libstdc++.so.6
#1  0x0002d184 in rpc_core::detail::msg_dispatcher::dispatch(rpc_core::detail::msg_wrapper) ()
#2  0x0002dab8 in std::_Function_handler<void (std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >), rpc_core::detail::msg_dispatcher::init()::{lambda(std::__cxx1
1::basic_string<char, std::char_traits<char>, std::allocator<char> > const&)#1}>::_M_invoke(std::_Any_data const&, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<cha
r> >&&) ()
#3  0x0002c174 in std::_Function_handler<void (std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >), asio_net::detail::rpc_session_t<(asio_net::detail::socket_typ
e)1>::init(std::weak_ptr<asio_net::detail::tcp_channel_t<(asio_net::detail::socket_type)1> >)::{lambda(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >)#4}>::_
M_invoke(std::_Any_data const&, std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >&&) ()
#4  0x0003cb00 in asio_net::detail::tcp_channel_t<(asio_net::detail::socket_type)1>::do_read_body(std::shared_ptr<asio_net::detail::tcp_channel_t<(asio_net::detail::socket_type)1> >)::{lambd
a(std::error_code const&, unsigned int)#1}::operator()(std::error_code const&, unsigned int) ()
#5  0x0003cc38 in asio::detail::read_op<asio::basic_stream_socket<asio::local::stream_protocol, asio::any_io_executor>, asio::mutable_buffer, asio::mutable_buffer const*, asio::detail::trans
fer_all_t, asio_net::detail::tcp_channel_t<(asi--Type <RET> for more, q to quit, c to continue without paging--
o_net::detail::socket_type)1>::do_read_body(std::shared_ptr<asio_net::detail::tcp_channel_t<(asio_net::detail::socket_type)1> >)::{lambda(std::error_code const&, unsigned int)#1}>::operator(
)(std::error_code, unsigned int, int) ()
#6  0x0003e0e4 in asio::detail::reactive_socket_recv_op<asio::mutable_buffer, asio::detail::read_op<asio::basic_stream_socket<asio::local::stream_protocol, asio::any_io_executor>, asio::muta
ble_buffer, asio::mutable_buffer const*, asio::detail::transfer_all_t, asio_net::detail::tcp_channel_t<(asio_net::detail::socket_type)1>::do_read_body(std::shared_ptr<asio_net::detail::tcp_c
hannel_t<(asio_net::detail::socket_type)1> >)::{lambda(std::error_code const&, unsigned int)#1}>, asio::any_io_executor>::do_complete(void*, asio::detail::scheduler_operation*, std::error_co
de const&, unsigned int) ()
#7  0x00022f3c in asio::detail::scheduler::do_run_one(asio::detail::conditionally_enabled_mutex::scoped_lock&, asio::detail::scheduler_thread_info&, std::error_code const&) ()
#8  0x000283dc in asio::detail::scheduler::run(std::error_code&) ()
#9  0x00015b58 in main ()
(gdb)

/home/xjf1127/codespace/git_down/pe-bluez_independ_sample/target/rpc_core/asio_net/include/asio_net/rpc_core/detail/msg_dispatcher.hpp

gpt分析：
这就意味着，不是你显式调用 unsubscribe 导致的，而是 回调里内部对 async_helper / msg_wrapper 的操作触发了内部 map 节点移动或析构。
回看你的 rpc::subscribe 里：

auto async_helper = std::make_shared<detail::async_helper>();
async_helper->is_ready = [rr] {
    return rr->rsp_ready;
};
async_helper->get_data = [rr = rr.get()] {
    return std::move(rr->rsp_data);
};


这里 rr 是一个 shared_ptr 对象，但你在 get_data 里捕获了 rr.get() 的裸指针。

如果 dispatch 在处理过程中决定发送 async response，并清理了原本 msg_wrapper 或 async_helper 的生命周期，这个裸指针就可能悬空。

当 map 内部可能移动或删除节点时，如果回调再次访问这个悬空指针，就会触发 Segmentation fault。

总结：你捕获了一个裸指针，而生命周期由外部 map 控制，所以在高并发 request/response 场景下就容易 crash。

为什么改成拷贝可以解决

你可以直接捕获 shared_ptr：

auto async_helper = std::make_shared<detail::async_helper>();
async_helper->is_ready = [rr = rr] {
    return rr->rsp_ready;
};
async_helper->get_data = [rr = rr] {
    return std::move(rr->rsp_data);
};


这里 rr 被 拷贝到 lambda 里，保持引用计数。

无论 dispatch 内部 map 怎么移动或析构临时对象，这个 lambda 持有的 shared_ptr 都确保对象有效。

避免了悬空指针访问的问题。

改动位置

你给的两个文件：

rpc.hpp：这是 RPC 对外接口和 subscribe 的实现

msg_dispatcher.hpp：这是内部 dispatcher，负责调用 handler 并处理异步响应

你只需要改 rpc.hpp 中 subscribe 函数，因为问题出在这里的 lambda 捕获方式：

auto async_helper = std::make_shared<detail::async_helper>();
async_helper->is_ready = [rr] { return rr->rsp_ready; };
async_helper->get_data = [rr = rr.get()] { return std::move(rr->rsp_data); };  // ❌ 这里捕获了裸指针


改成：

auto async_helper = std::make_shared<detail::async_helper>();
async_helper->is_ready = [rr] { return rr->rsp_ready; };
async_helper->get_data = [rr] { return std::move(rr->rsp_data); };  // ✅ 捕获 shared_ptr


以及下面 rr->rsp lambda：

rr->rsp = [rr, hp = async_helper](Rsp rsp) mutable { ... };


保证所有 lambda 都 捕获 shared_ptr rr，而不是裸指针。

核心说明

不用改 msg_dispatcher.hpp，它只是调用你注册的 lambda 并处理 async 响应。

只要 lambda 捕获了 shared_ptr rr，即使外部函数返回，rr 仍然存在，不会悬空。

你原来的 crash 就是因为 rr.get() 在 lambda 内部使用时可能已经被销毁。
```


### shared_ptr的应用

1. 比如进程管理模块，通常是从工厂模板中创建的一个对象，这个对象通常包含某种功能业务逻辑完整的声明周期和控制，那么创建出来通常经过这个分享到其他的业务模块中调用，并且可能会多个模块进行调用，并且是多线程环境 或者是一个rpc调用，一个有生命周期的数据结构  闭包

2. 在一个临时作用域创建的，生命周期长时间存在的变量