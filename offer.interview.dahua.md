---
id: 5vucmw5qwgi8sld8bc2g3id
title: Dahua
desc: ''
updated: 1739424395262
created: 1735199459023
---

#### c++
### 详细说说C/C++中malloc、free和new、delete的异同点
  - malloc 是函数，只进行内存分配，不调用构造函数，返回void*指针，并且需要进行NULL判断和类型强转
  - new 操作符，不仅会进行内存分配还会调用构造函数，并且有些编译器实现会进行内存对齐，不需要类型墙砖
### C++中引用及其使用
  1. 引用是变量别名，所以不能像变量或者指针一样直接引用
  2. 引用底层一般由指针实现
  3. 使用引用时，通常要考虑目标变量的来源，不能引用可能已销毁变量
  4. 通常的使用场景，传递变量，遍历数组元素，简化部分场景的指针解引用写法，增加可读性
### 结构与联合有什么区别？union中可以放class对象吗？
  1. 结构体内部每个成员都有独立空间，按声明顺序进行分配内存，可能会进行内存对齐
  2. 联合所有成员共用一块空间
  3. union和class，class不能有自定义的构造函数以及虚函数，并且不会自动调用，要调用也是显式调用, 应为union不允许有额外的字段
### c++的static的作用
  1. 静态全局变量和函数只对当前编译单元对应的文件可见，不同文件可重名
  2. 静态局部变量，比如在函数中的静态变量，是在第一次在函数中执行到对应的static声明的语句时分配，分配的是静态存储区域
  3. 类中的静态成员变量和静态函数，都没有this指针，并且所有对象共享内存，并且必须在类的声明外进行单独定义，内存分配和初始化都和全局静态对象一样，在静态初始化阶段初始化即进入main函数之前。
### 关于移动语义，move，左值，右值
  1. 这些都是在c++11中新增的概念和关键字，都是实现移动语义的语法工具，方便地通过隐式的方式转移对象资源
  2. 左值通常是 明确了存储位置的值, 如变量，数组，引用等, 如可以通过取引用的，都是左值
  3. 右值通常是 临时值，如表达式结果，函数的返回值等
  4. std::move的作用，主要还是改变变量的左右值属性，然后显示地触发移动语义，所以关键在于显式触发对象的移动语义
### 孤儿进程、僵尸进程和守护进程
  1. 僵尸进程就是死了但又没完全死，活死人状态 子进程本身是已经结束了，但进程信息还留在进程表中，没有父进程进行wait确认
  2. 孤儿进程就是进程本身还存在的，父进程却死了，由init进程接管
### 进程中断时会发生什么？
  1. 保存寄存器相关上下文
  2. 保存数据，堆栈等进程上下文
### 互斥锁和原子操作的区别？
  1. 互斥锁保证同一个时刻，只有一个线程进入临界区，其余的进入休眠
  2. 原子操作一般需要硬件支持，保证简单的读写操作，在多线程环境下安全
### 物理内存和虚拟内存？
  1. 物理内存通过mmu单元映射为虚拟内存，来给每一个进程提供一个隔离的独立的内存空间
### io复用和异步网络编程和协程？
  1. 协程本身是在线程基础上的概念，他的目的是高效利用io操作，来减少线程的开销
  2. io复用 复用的是指进行io操作的线程，一个线程去监听多个io操作，提高线程的利用率, 阻塞的io是两次进程切换+两次阻塞 一次是等待数据到达，一次是等待数据从内核缓存拷贝到用户缓存，而io复用则是解决了等待数据到达的问题，拷贝的阻塞还是存在的
  3. select，poll，epoll， select有描述符限制，poll是select的改进，没有数量限制，但每次调用都需要重新设置描述符集，epoll可以边缘触发，即设置一次描述符集并且一直监听
  4. reactor，proactor 二者都是事件驱动分发的模型，reactor基于未完成的io，就是系统只负责通知你可以执行io操作了；proactor是基于已经完成的io，通知你的时候，io操作已经结束了。
### 多态 虚函数 纯虚函数？
### c++的虚函数实现，以及纯c的类虚函数的实现？
  1. 如果一个c++的类有虚函数或者继承行为的，他会包含一个虚函数指针，这个指针指向一个虚函数表，虚函数表是用来记录类继承关系的数据结构
  2. 类的虚函数存储在代码段，虚函数表存储在数据段, 虚函数指针在对象构造时初始化，先于执行初始化列表之前
  3. 个人对虚函数的理解，这是一种回调，只是由实际类型决定最后回调的执行
### 虚函数表的创建和虚函数指针的初始化？
  1. 在编译期间，每一个类生成一个虚函数表
  2. 虚函数指针的更新
     1. 在对象构造时，将对应的虚函数表地址赋值给虚函数指针
     2. 在按继承顺序依次从基类到继承类构造时，每一级构造函数将vptr更新为当前类对应的虚函数表，如果在构造函数中调用虚函数，那么钓鱼呢的会是已经完成构造的版本，即子类构造函数中调用虚函数，将会调用基类的版本
     3. 子类指针赋值给基类指针时，会更新

### 常用的设计模式? 用在哪些地方? 懒汉和饿汉的区别?为什么c++11创建单例的方式是线程安全的?
设计模式分三个类别:
1. 创建型
   1. 单例模式
      1. 懒汉，用到时才会初始化，可以节省内存，缺点，需要加锁防止线程冲突，大部分的配置文件以及日志模块，都是懒汉。
      2. 饿汉，在程序启动时就自动初始化，优点没有线程安全问题。如gtest中的所有case，就是饿汉。
      3. c++11的单例写法为什么线程安全的？c++11标准的编译器会为局部静态变量生成隐藏的标志位，来指示线程的访问，防止同时访问。在c++98上并没有这个保护
   2. 工厂模式, 统一一个接口，来返回对象
   3. build模式, 在java中用的多,通过链式调用，将对象的构建过程化
2. 结构型
   1. 适配器: 用来将一个接口转化为另一个接口，实现方式通常是在 存在一个标准接口A，不标准接口B，然后通过一个类C去继承接口A的类来重写，将接口B包装在实现里面
   2. 装饰器: 首先装饰器的核心 是让装饰器的行为与目标基类一致，但在部分接口的功能上是基于目标基类扩展的，也就要求装饰器要继承目标基类，然后又持有目标基类的指针，这样子装饰器的子类就能够对某些接口功能进行扩展方式重写；在c++上面的实现通常是：首先存在目标基类A，然后是定义装饰器T基类继承A并且在内部持有一个A的指针，然后装饰器T的子类复写目标功能接口并且调用内部持有的基类。
3. 行为型: 本质上就是虚函数的回调
   1. 观察者模式 在gui框架中的事件分发中常用，所有事件基于一个基类，事件中心会在一个事件生成时，遍历持有的所有的监听器，调用回调
   2. 策略模式
### 在书中以及设计模式在项目中的应用?
1. 在深入应用c++11，代码优化和工程级应用的书中
   1. 设计模式
   2. 组件实现: 线程池，对象池，消息总线
   3. c++11的现代语法: 
      1. 模板推导，模板特化
      2. 列表初始化
      3. lambda表达式
      4. 类型萃取
      5. 智能指针
      6. 右值引用 移动语义
      7. 互斥量
      8. 条件变量
      9. 原子操作
      10. 异步操作类 promis future package_task
2. 在c++并发编程实战的书中
   1. 各种数据竞争问题
   2. c++的RAII机制
   3. 线程池
   4. 并发代码的各种实现方式
3. mongoose网络库
   1. 事件驱动模型
   2. 模型的实现构成: 
      1. 事件循环 event loop
      2. 事件回调 event callback
      3. 非阻塞io + 定时器
      4. 链接管理器
4. gtest测试框架
   1. 静态全局注册, 利用全局静态变量的初始化来进行所有case的初始化
5. spdlog日志库
### 锁类型，递归锁，读写锁等应用场景？
1. 锁的种类: 互斥锁，递归锁，读写锁，自旋锁
2. 其他同步手段: 条件变量，互斥量，原子变量
3. 互斥锁: 准确来说，只能一个时刻，一个线程，一次加锁，进入临界区。 `三一`
4. 递归锁: 准确来说，只能一个时刻，一个线程，但是同一个线程允许反复加锁，进入临界区，比如递归场景下，以及函数A，函数B会互相调用，并且都用了一把锁，但只要在一个线程内，那么就可以反复加锁。
5. 读写锁: 允许同一时刻，多个线程读取，但只允许一个线程进行写入,意味着写入时是互斥的，读取时是并行的。一个锁变量分两种加锁操作，在代码中显式使用，分别表示读和写操作。
6. 自旋锁: 自旋锁和互斥锁不同，自旋锁的性能会更好，如果锁已经被其他线程拿到，那么当前线程进入临界区时不会休眠，而是原地不断检查，响应更及时。
### 在项目中死锁的场景？怎么解决的,用的什么排查方法？
1. fork进程相关时，printf死锁问题
   1. 在多线程的环境下，父进程的多线程中的一个线程调用fork，生成子进程，然后在子进程的代码段中调用 exec 函数族加载替换子进程内存前调用printf，导致线程阻塞，原因: 在多线程环境下，fork子进程的瞬间，后台线程调用printf持有全局锁，子进程继承了加锁的互斥锁，导致再次调用printf后会立刻阻塞。
2. 死锁问题更多是在 使用条件变量的过程中，由于各种条件不满足导致的死锁 ！！！！！无法在正确的时机进行notify，比如准备通知的线程已经被其他锁给阻塞，根本无法notify，或者是由于空指针引用，导致条件无法成立，一直死锁
### 条件变量的使用，在项目中的使用，要注意什么？
1. 配合互斥量
2. 防止虚假唤醒，需要配合while，即被唤醒后要重新检查条件，如果不满足则继续wait
### shareptr的使用，哪些场景下使用？循环引用是什么？weakptr怎么使用?
1. 首先智能指针 要明确 智能指针对象和引用对象这两种对象以及两种析构行为，整个过程就是 通过智能指针对象的析构行为 改变引用计数来 触发决定引用对象的析构是否触发
2. 类型A和类型B，二者内部都互相持有对方类型的shareptr对象，当定义shareptrA和shareptrB对象时，并且将自身赋值给对方，此时S_A计数2，S_B计数2，脱离作用域以后，A，B，SA，SB，A.SB，B.SA, 此时SB SA由于离开作用域，触发了智能指针的析构，各自减1，但是此时对象本身并没有析构，而A对象的析构，依赖于A对象的SA计数为0，而SA被B对象持有，相反B对象也是同样的情况，双方互相持有对方的计数，依赖对方对象的析构才能使智能指针计数为0，导致资源泄露
3. 通过weakptr来打破循环引用，可以将其中一个对象的持有shareptr类型改为weakptr，将一个shareptr赋值给他不会增加引用计数，并且需要通过weakptr返回shareptr时，可以通过weakptr的lock函数返回一个shareptr
### 性能优化，在迭代器的使用过程中，++i和i++有什么区别？
i++是后置递增，每次先保存i的副本，然后对i进行递增, 然后返回
++i是前置递增，每次先对i进行递增，然后返回
### 智能指针和数组
### char* p的
### tcp 的了解，以及tcp相关功能的实现？ 
### 网络问题排查？wireshake可以看哪些东西？红圈圈？
### socket实现简单的http协议，websocket协议?
### socket编程的顺序?
### 网络大小端?
### 整理看过的书
### 关于c++类的内存结构和虚函数表的小实验
### 音视频同步如何实现的？ 
### 前公司项目讲解，以及绘制相关架构图
### 虚函数的声明位置和虚函数表的关系?
### 虚函数表的静态和动态，初始化，以及和类的构造
### 对yuv的了解
### 对h264编码的了解

### extern的作用
### c++ 声明和定义的作用
### c和c++ static的区别
### C语言的面试题

### c++类的内存模型
### linux程序的内存结构
### 编译 链接相关的调试命令
### nvr/dvr

### qt面试题

### 

#### 问题调试

#### 操作系统

#### 音视频

#### 网络

#### 项目经验

#### 公司了解

#### 自我评价
1. 我在上一家公司的面试工作情况呢，是从21年实习期就开始

#### 还有什么要问的吗
1. 面试流程 有多少面
2. 小组结构，做什么事情

#### 改简历
1. qt 项目详细化
2. 音视频 ui工具以及框架详细化
3. 新增系统进程间通信，如android和linux

### 岗位技能
DSP
BSP
GB28181
Onvif/Dante/NDI
HTTP/RTSP/RTMP/SIP/MDNS
常见设备驱动(串口，网口，硬盘)
常见总线驱动模型(IIC, PCI)
QT vtk
ROS ROS2
linux 内核移植 系统开发 驱动开发
h264/h265 音视频编解码原理
熟悉FreeRTOS uC/OS-II等实时操作系统开发经验者优先
NVR录像机

### 自我介绍
你好，我在上家公司待了差不多有3年左右，主要做的是公司内部 c++相关的工具开发，用于支撑公司内部业务部门的需求，比如采集部门和质量部门，然后开发的工具平台一部分是在车载车机上 一般是qnx和linux以及android系统 ，集成公司的视觉检测算法，进行音视频的处理和渲染
还有就是pc的客户端，做一些音视频采集以及视觉算法相关的客户端应用, 
然后的话我就 简历里提及的项目做一下简单的介绍

第一个设备端的代理，它是一个运行在车载车机系统上面的c++服务程序，主要作用就是作为一个中间件，响应上层平台下发的任务请求，作为一个消费端 对集成了视觉检测算法的进程进行 部署 以及运行时的调度管理。 
主要涉及的技术栈就是 进程间的通信，以及进程管理，还有各种应用层的协议的管理。

第二个的话就是在设备上的视觉检测算法的可视化工具。它主要是集成了各种算法sdk，然后在客户车机上直接运行 作为一个可视化的工具 提供给内部测试部门以及公司客户使用
主要分为渲染模块，gui事件处理模块，音视频编解码加渲染模块，还有算法管理模块 以及相机取流管理等。 由于客户的车机系统环境差异比较大 所以现成的gui框架，比如qt的移植使用不是很合适。所以渲染模块是直接使用的 opengles，在项目的初期是直接基于opengles封装了渲染的接口，来作为整个app的gui框架的，后期呢升级为了部分
基于opengles的开源ui框架，在这个基础上进行扩展。 那么使用人员在使用的时候 一个是可以在实车的车机上 进行一个视觉算法效果的预览，以及各种参数设置，另一方面可以进行截屏，视频录制等相关的功能。
这类工具的话还有部分是在 android系统，以及android-linux双系统上的

第三类的话就是主要是在pc客户端的开发，主要做的是 音视频采集客户端，基于采集卡，适配公司涉及业务的所有镜头，比如车载的相机，还有一些网络相机，来进行一个多路视频流的同步采集, 提供来给公司的采集部门.

#### h3c
### 进程和线程的区别以及关联?
1. 地址空间，每一个进程拥有独立的地址空间(虚拟内存)，包括文件描述符，代码段，数据段，堆和栈，而一个进程下的线程共享地址空间
2. linux上的进程和线程用的是统一的模型，都用task表示，对应数据结构task_struct,通过clone系统调用进行创建，根据参数不同来决定是否进行资源共享,即线程是特定的进程

### 哪些东西是线程独有的? 以及gdb调试可以查看回溯栈原理?
1. 线程栈，每一个线程都拥有私有的栈，意味着其他线程不可访问，比如每进入一个函数，就会分配一个栈帧,它会保存
   1. 当前栈帧的函数实参
   4. 当前栈帧的局部变量
   2. 返回地址：是在当前函数栈帧结束时候用的，在栈帧创建时初始化,起保存 *目的是离开当前栈帧后，在旧栈帧中指令的指向*
   3. 旧的栈指针(上一个栈帧的栈启点): 也是在当前函数栈帧结束时候用的，在栈帧创建时初始化,起保存作用 *目的是离开当前栈帧后，恢复为旧栈帧环境*
2. 在函数调用过程中栈和栈帧变化，比如main函数调用A函数，A函数内部调用B函数?
  1. 在进入函数时创建新栈帧，并保存旧栈帧数据
  2. 新栈帧对应函数结束时，使用旧栈帧数据恢复栈帧上下文
  3. 类似于链表结构，当前节点保存上一个节点数据用于指向，旧栈指针是为了恢复环境，返回地址是为了进入环境对应的指令
3. 疑问: 栈帧恢复时，对这几个成员引用的顺序?局部变量是只有执行到才会进行记录保存吗？局部变量空间的分配和初始化
   1. 当函数需要return时，先使用当前栈帧的返回地址，来指向下一条指令
   2. 然后是旧栈指针的恢复，让局部变量和栈帧结构生效
   3. 首先进入函数以后，栈空间就会被分配好内存，包括函数内的局部变量是被一次性分配内存的，但是局部变量的初始化，依赖于运行时执行到的具体语句；
4. errno变量也是线程独有的一个全局变量
### 栈和堆的区别？存储哪些东西?
1. 栈的内存分配是自动的，由系统内核进行分配和释放管理, 内存生命周期由编程语言的规则决定, 并且是线程安全的, 线程之间的栈私有独立,速度快
    存储局部变量，函数参数，返回地址，即在运行时函数调用链过程中的环境和上下文数据
2. 堆的内存分配是动态的，需要应用程序手动申请并且手动释放, 不线程安全，需要应用程序进行多线程保护, 速度慢
### 进程的内存结构? BSS和data segment有什么区别? 字符串常量这些是怎么存储的？
1. Text segment: 只读的机器码，程序指令
2. data segment: 全局变量和静态变量, 初始化时有明确的值, 属于静态内存分配, 程序启动时，需要从可执行文件中读取值进行初始化
3. BSS segment(block started by symbol): 未初始化的全局变量，也属于静态内存分配,程序启动时分配好内存即可，不需要从可执行文件中获取值进行初始化
4. heap: 动态内存分配
5. stack: 线程私有的，函数调用过程中的栈帧存储
6. mapping segment(高地址区域)
常量字符串这些都属于只读数据段,可以归纳到data segment
### 进程间通信的方式?
进程间通信 IPC, 无论是哪种通信方式，都需要资源描述符来标识通信
本机:
1. 管道
2. 命名管道 fifo
3. 消息队列
4. 共享内存
多主机间:
1. 套接字
### 进程同步手段?
通信是为了传递数据，同步是为了协调 进程或者线程的 执行顺序
1. 信号量
2. 文件锁
3. 信号
### 进程同步要注意什么？每种同步手段要注意什么?
### 什么是原子操作?
### 文件锁有用过吗?fcntl和flock的区别？如何对文件的部分而不是整个文件进行加锁? 和读写锁的差异?锁的来源不同
1. 文件锁是多进程间 文件访问同步的机制，可以理解为进程间的读写锁,分共享锁(shared_lock)和独占锁(execlusive),分享锁可以多个进程同时读取,独占锁只能一个进程进行读写
  **通过打开同一个文件的fd，作为锁的来源**
  fcntl可以控制文件的部分进行加锁，设置在文件中的偏移量和长度，以及持有锁的进程的id
  
1. 读写锁是多线程间的共享数据的读写保护。通过创建共享的锁对象作为锁来源。
2. 文件锁的系统调用: fcntl 和 flock
3. 读写锁的系统调用: pthread_rwlock_t 
### 内存映射有了解过吗？对文件进行一个内存映射？
1. 内存映射就是将文件内容映射到进程的虚拟内存空间中，一般通过mmap系统调用进行内存映射;以操作内存的方式，进行文件io的处理
2. 内存映射的系统调用:mmap munmap
3. 整个过程就是获取到文件fd以后，再通过mmap，设置文件偏移量和属性以后，映射返回一个指针，再按指针的方式进行操作
4. 注意: 修改有延时性，应该修改后调用msync, 有冲突的地方需要加锁，比如文件锁等
### 共享内存有用过吗？进程间的共享内存和线程间的共享内存？
1. 和文件内存映射一样，都是通过mmap来进行内存映射，返回一个指针
2. 区别在于 共享内存使用 shm_open获取fd作为mmap的参数，文件映射通过open文件获取fd
### 进程间信号量有了解过吗？
1. 系统调用 sem_open sem_wait sem_post ,通过获取信号量名字获取一个fd，然后作为操作参数，wait相当于减1，post相当于释放，wait信号量为0时则阻塞
### 申请了10M的内存但是读取了20M的内存是属于什么？内存泄漏和内存溢出有什么区别?
内存泄漏指的是 动态分配的内存，没有正常的释放，最终导致内存不足
内存溢出是指 程序访问超出了实际可用范围的内存，比如:
1. 数组或者指针访问越界
2. 函数递归调用，导致栈空间用尽
### 内存分页是什么？


gdb有用过吗，怎么看不同线程情况？
内核空间和用户空间的区别？
用户空间和内核的通信方式?
sizeof的相关问题?


### 华消科技
- 面试询问
  你好，我在年前参加了贵公司 嵌入式软件岗位的面试，当时面试流程暂缓了，我想请问一下，大概啥时候能参加下一轮面试

- 对公司的了解
  - 我在咱们公司的官网看了，主要是做消防业务相关的物联智能化产品，以及城市智慧消防的解决方案，我对这个方向比较感兴趣
  - 我个人也是比较希望在这个方向深耕的，
- 必问问题:
  - 为什么选择裸辞了呢?
    - `职业方向`: 一个是我一直比较向往 嵌入式，物联网这个职业方向，希望在这个方向深耕，在上家公司主要做的公司内部工具的开发，主要是和公司内部部门比如算法部门合作，进行一个算法应用的预研等，涉及的技术栈会比较多，但也比较分散,所以我更希望专注于物联网,大数据平台化的这个方向 以及像驱动，内核这些方向
    - `个人情况`: 另一方面，刚好那段时间家里有事处理,加上按我个人性格在职很难兼顾去求职，所以最后还是决断先处理个人事务
  - 裸辞这段时间在做什么?
    - 一方面准备面试
    - 另一方面 学习一些技术，协议， 比如最近在了解 sip，和音视频通话相关的开源库，项目
  - 在原公司做的什么?
    - 主要是做内部工具的开发，比如在车机设备上，然后就是pc客户端

- 薪资可能达不到你的预期
  - 薪资是一个参考要素，我更看中平台和工作内容
- 还要一个事情我需要和公司说明一下，不知道你们会不会介意
  - 
- 领导面准备:
- hr面准备:
  - 根据简历内容进行提问?
  - 讲一下自己的项目经理?
  - 兴趣爱好，喜欢的书，喜欢的电影，做饭
  - 技术书籍

- 接话: 能耽误你几分钟吗，我想了解一下关于?


### 心里
- 盯着屏幕刷boss的感觉真的很难受
- 已读不回是真混蛋
- 社会毒打的第一课: 求职
- 自闭了
- 人们心中的成见是一座大山，包括自己
- 人在绝境中唯一能做的，就是不停的审视自己的现有条件，一次次整理后再出发
- 在被已读不回的第一瞬间为什么羞愤的仅仅是自己的学历，而不是想着优化简历内容
- 好一个问心局

- 2025/02/09
  - [x] 优化简历 0.5小时
  - [x] 优化boss收藏 10分钟
  3. anki 面试问题整理，并且自测 1小时
  4. sip understand 0.5小时
  5. 运动0.5小时
  - [x] 岗位收藏30分钟
- [ ] 2025/02/10
  - [ ] anki 面试问题整理，并且自测 1小时
  - [ ] sip understand 0.5小时
  - [ ] 运动 0.5小时
  - [ ] 刷简历 0.5小时
  - [ ] 整理qt项目描述
- [ ] 2025/10/12
  - [ ] qt, minigui
  - [ ] http mqtt rpc
  - [ ] 负责模块: 日志，机械运动，数据收发，协议对接
  - [ ] 买米
  - [ ] 买抓头发的
  - [ ] 回顾旧的面试问题
  - [ ] 代码量整理
  - [ ] opengl渲染过程